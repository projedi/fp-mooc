# Step 1 (Show)

Для преобразования в строку в Haskell есть класс типов `Show`:
```
class Show a where
   show :: a -> String
```
Он в том числе используется ghci, чтобы напечатать результат.
Вот пример реализации инстанса для бинарного дерева:
```
data Tree a
   = Leaf a
   | Branch (Tree a) a (Tree a)

instance Show a => Show (Tree a) where
   show (Leaf x) = show x
   show (Branch l x r) = "(" ++ show l ++ ") " ++ show x ++ " (" ++ show r ++ ")"
```

# Step 2 (Exercise: Implement Show instance for binary trees by drawing)

Реализовать инстанс `Show` для деревьев, который бы "рисовал" деревья:
```
data Tree a
   = Leaf a
   | Branch (Tree a) a (Tree a)

-- show (Leaf 0) == "0\n"
-- show (Branch (Leaf 0) 1 (Leaf 2)) == " 1 \n\
--                                      \0 2\n"
-- show (Branch (Branch (Leaf 0) 24 (Leaf 22)) 45 (Branch (Branch (Leaf 34) 37 (Leaf 8)) 100 (Leaf 1))) ==
--    "     45         \n\
--    \ 24         100 \n\
--    \0  22    37    1\n\
--    \       34  8    \n\
```
*Подсказка*: Напишите вспомогательную функцию, которая строит отрисованное дерево построчно (так проще
склеивать два поддерева при обработке `Branch`). А `show` просто вызовет эту функцию и применит к результату `unlines`.

# Step 3 (Show is slow)

Посмотрим теперь на производительность `show`:
```
data Nat = S Nat | Z

instance Show Nat where
   show Z = "0"
   show (S n) = show n ++ "+1"

-- show (S (S Z)) =>
-- show (S Z) ++ "+1" =>
-- (show Z ++ "+1") ++ "+1" =>
-- ("0" ++ "+1") ++ "+1"
```
Мы получили последовательность скобок, при которой время работы `(++)` наихудшее.
Попробуем исправить ситуацию:
```
type ShowS = String -> String

showNat :: Nat -> ShowS
showNat Z = ("0" ++)
showNat (S n) = showNat n . ("+1" ++)

instance Show Nat where
   show n = showNat n ""

-- show (S (S Z)) =>
-- showNat (S (S Z)) "" =>
-- (showNat (S Z) . ("+1" ++)) "" =>
-- (\x -> showNat (S Z) ("+1" ++ x)) "" =>
-- (\x -> (showNat Z . ("+1" ++)) ("+1" ++ x)) "" =>
-- (\x -> (\y -> showNat Z ("+1" ++ y)) ("+1" ++ x)) "" =>
-- (\x -> (\y -> "0" ++ ("+1" ++ y)) ("+1" ++ x)) "" =>
-- (\x -> "0" ++ ("+1" ++ ("+1" ++ x))) "" =>
-- "0" ++ ("+1" ++ ("+1" ++ ""))
```
Использование композиции для конкатенации строк исправило ситуацию.
Можете проверить, что если showNat выглядел бы так:
```
showNat :: Nat -> ShowS
showNat Z = ("0" ++)
showNat (S n) = ("1+" ++) . showNat n
```
то последовательность скобок осталась бы эффективной.

# Step 4 (Show again)

Этот трюк на самом деле используется и в самом `Show`. Вот как класс выглядит на самом деле:
```
class Show a where
   showPrec :: Int -> a -> ShowS
   show :: a -> String
   showList :: [a] -> ShowS
```
Достаточно реализовать `showPrec` *или* `show`.
`showList` позволяет переопределить, как будет показываться список элементов (используется в
`Show Char` для обработки `String`).
`showPrec` первым аргументом принимает приоритет оператора в окружающем контексте (от 0 до 11) ---
используется, например, при выводе инфиксных операторов.

Также есть набор вспомогательных функций:
```
shows :: (Show a) => a -> ShowS
shows = showPrec 0

showChar :: Char -> ShowS
showChar = (:)

showString :: String -> ShowS
showString = (++)

showParen :: Bool -> ShowS -> ShowS
showParen b p = if b then showChar '(' . p . showChar ')' else p
```

# Step 5 (Exercise: Implement Show instance for expressions)

Реализовать инстанс `Show` для арифметических выражений:
```
data Expr
   = Val Int
   | Sum Expr Expr
   | Mul Expr Expr

-- show (Sum (Mul (Val 1) (Val 2)) (Mul (Val 3) (Val 4))) == "1 * 2 + 3 * 4"
-- show (Mul (Sum (Val 1) (Val 2)) (Sum (Val 3) (Val 4))) == "(1 + 2) * (3 + 4)"
-- show (Sum (Val 1) (Sum (Val 2) (Val 3))) == "1 + 2 + 3"
-- show (Mul (Mul (Val 1) (Val 2)) (Val 3)) == "1 * 2 * 3"
```

# Step 6 (Read)

Помимо преобразования в строку в Haskell есть так же класс для преобразования из строки, `Read`.
Вот, как обычно, его часть вместе со вспомогательными функциями:
```
type ReadS a = String -> [(a, String)]

class Read a where
   readsPrec :: Int -> ReadS a
   readList :: ReadS [a]

reads :: Read a => ReadS a
read :: Read a => String -> a
readParen :: Bool -> ReadS a -> ReadS a
lex :: ReadS String
```
Достаточно определить `readsPrec`.

* `ReadS a` --- парсер для `a`: принимает на вход строку и возвращает список возможных результатов
  `(a, String)`, где `String` --- остаток строки, не участвовший в парсинге.
* `readsPrec` --- так же, как и `showPrec` принимает первым аргументом приоритет оператора
  в окружающем контексте.
* `readList` --- так же, как и `showList` используется для особой обработки парсинга списков.
  И используется в инстансе `Read Char`.
* `reads` --- эквивалентно `readsPrec 0`.
* `read` --- попытается *полностью* распарсить вход и упадет с ошибкой при неудаче.
* `readParen` --- `readParen True p` парсит `p`, заключенное в скобки;
  `readParen False p` парсит `p`, *возможно* заключенное в скобки.
* `lex` --- прочитать одну лексему, пропустив лидирующие пробелы. Лексема:
    - `'a'` --- символьный литерал
    - `"abc"` --- строковый литерал
    - `foo123'` --- идентификатор в Haskell
    - `<<`, `:`, ... --- оператор в Haskell
    - `(`, `::`, ... --- пунктуация и зарезервированные символы в Haskell
    - `12.3e-45` --- число

# Step 7 (Read example)

В качестве примера, рассмотрим парсинг времени поддерживающий как "22:34", так и "10:34PM":
```
data Time = Time
   { hours :: Int
   , minutes :: Int
   }
   deriving Show

data DayPeriod = AM | PM

instance Read DayPeriod where
   readsPrec p = go
    where go (' ':s) = go s
          go ('A':'M':s) = [(AM, s)]
          go ('P':'M':s) = [(PM, s)]
          go _ = []

instance Read Time where
   readsPrec p s =
      [ (t, s'')
      | ((h, m), s') <- hoursMinutes s
      , (dp, s'') <- readsPrec p s'
      , t <- case dp of
                AM -> [ Time (h `rem` 12) m | h >= 1 && h <= 12 ]
                PM -> [ Time (h `rem` 12 + 12) m | h >= 1 && h <= 12 ]
      ] ++
      [ (Time h m, s')
      | ((h, m), s') <- hoursMinutes s
      , h >= 0 && h < 24
      ]
    where
      hoursMinutes :: ReadS (Int, Int)
      hoursMinutes s =
         [ ((h, m), s'')
         | (h, (':' : s')) <- readsPrec p s
         , (m, s'') <- readsPrec p s'
         , m >= 0 && m < 60
         ]
```
Если это выглядит не очень элегантно, то все как надо. Инструменты, которые позволят писать приличный
код для парсинга будут рассмотрены в последних двух модулях этого курса.

Инстанс для `DayPeriod` смотрит на входную строку, пропускает лидирующие пробельные символы и, если
строка начинается с `"AM"` или `"PM"`, возвращает соответственно `AM` или `PM` вместе с остатком строки.
Иначе возвращает пустой список результатов.

Инстанс для `Time` использует генераторы списков возможно неожиданным способом. Идея в том, чтобы рассматривать
функции, возвращающие списки, как недетерминированные вычисления: списком на выходе мы возвращаем все
возможные результаты этого вычисления (которых может быть любое количество, в том числе 0). В этом случае под
```
[ y | y <- f, y >= 0] ++ [ y | x <- f, y <- g x, y >= 0 ]
```
понимается недетрминированное вычисление, возвращающее либо неотрицательное значениe `f`, либо неотрицательный
результат применения `f` к `g`.

Посмотрим теперь на парсинг `Time`. Подпарсер `hoursMinutes` можно читать так:

1. Читаем `Int`, за которым следует `:` и храним этот `Int` в `h`.
2. Читаем `Int` и храним его в `m`.
3. Требуем `m >= 0 && m < 60`.
4. Возвращаем пару `(h, m)`.

Сам парсер состоит из 2-х частей. Пытаемся распарсить вход как:

* либо с наличием AM/PM:
    1. Читаем `(h, m)` с помощью `hoursMinutes`.
    2. Читаем `DayPeriod` и храним его в `dp`.
    3. В зависимости от `dp` ставим ограничения на `h` и конструируем `Time` из `h` и `m`.
* либо без:
    1. Читаем `(h, m)` с помощью `hoursMinutes`.
    2. Требуем `h >= 0 && h < 24`.
    3. Возвращаем `Time h m`.

Вызов `read s` для парсинга `Time` тогда будет смотреть на результат `readPrec 0 s`:

* Если есть ровно один результат, с пустой оставшейся строкой, то он вернет его.
* Если есть несколько таких результатов, то упадет, сказав, что парсинг недетерминированный.
* Если нет ни одного результата, либо все результаты имеют какую-то оставшуюся строку, то
  упадет, сказав, что парсинг неудачный.

# Step 8 (Exercise: Implement Show and Read instances to transform expression to PN and back)

Польская запись --- запись выражения в префиксной форме (оператор следует перед своими
аргументами). Например, "+ * 1 2 * 3 4" в инфиксной форме выглядит как "1 * 2 + 3 * 4".

Реализовать инстансы `Show` и `Read` для преобразования выражения в польскую запись
и обратно:
```
data Expr
   = Val Int
   | Sum Expr Expr
   | Mul Expr Expr

-- show (Sum (Mul (Val 1) (Val 2)) (Mul (Val 3) (Val 4))) == "+ * 1 2 * 3 4"
-- read " + * 1 2 3  " == Sum (Mul (Val 1) (Val 2)) (Val 3)
```
