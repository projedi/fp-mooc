<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
  <link rel="stylesheet" href="highlight/styles/default.css">
  <script src="highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<!--
vim: ft=markdown
-->
<h1 id="уроки">Уроки</h1>
<h2 id="введение-в-классы-типов">Введение в классы типов</h2>
<h3 id="step-1-implementing-iselemof">Step 1 (Implementing <code class="haskell">isElemOf</code>)</h3>
<p>Попробуем реализовать функцию, использующую равенство, — <code class="haskell">isElemOf</code>.</p>
<p>Ясно, что реализация равенства зависит от типа, элементы которого сравниваем, поэтому нету функции на верхнем уровне вида <code class="haskell">(==) :: a -&gt; a -&gt; Bool</code>. Можно попробовать передавать реализацию равенства аргументом:</p>
<pre><code class="haskell">isElemOf :: (a -&gt; a -&gt; Bool) -&gt; a -&gt; [a] -&gt; Bool
isElemOf _ _ [] = False
isElemOf eq x (y : ys) = x `eq` y || isElemOf eq x ys</code></pre>
<h3 id="step-2-exercise-implement-issublistof">Step 2 (Exercise: implement <code class="haskell">isSublistOf</code>)</h3>
<p>Реализовать в терминах <code class="haskell">isElemOf</code>:</p>
<pre><code class="haskell">isSublistOf :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [a] -&gt; Bool
-- isSublistOf (==) [] [] == True
-- isSublistOf (==) [] [1, 2, 3] == True
-- isSublistOf (==) [2, 1] [1, 2, 3] == True
-- isSublistOf (==) [2, 4] [1, 2, 3] == False</code></pre>
<h3 id="step-3-typeclasses">Step 3 (Typeclasses)</h3>
<p>А что если для нашей функции мы хотим передать не только реализацию равенства, а еще преобразование в строку и оператор <code class="haskell">(&lt;)</code>? Придется передавать 3 дополнительных аргумента и при этом первый и третий легко перепутать, так как они имеют одинаковый тип <code class="haskell">a -&gt; a -&gt; Bool</code>. Haskell предоставляет механизм классов типов, который позволяет автоматизировать процесс:</p>
<pre><code class="haskell">class Eq a where
   (==) :: a -&gt; a -&gt; Bool</code></pre>
<p>Здесь мы декларируем функцию <code class="haskell">(==)</code> в <em>классе</em> <code class="haskell">Eq</code>. <code class="haskell">isElemOf</code> теперь можно переписать так:</p>
<pre><code class="haskell">isElemOf :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
isElemOf _ [] = False
isElemOf x (y : ys) = x == y || x `isElemOf` ys</code></pre>
<p>В сигнатуре функции все, что между <code class="haskell">::</code> и <code class="haskell">=&gt;</code> называется <em>контекстом</em>. В данном случае он состоит только из <code class="haskell">Eq a</code> и используется в качестве неявного аргумента для передачи функции <code class="haskell">(==)</code>.</p>
<h3 id="step-4-exercise-implement-issublistof-again">Step 4 (Exercise: implement <code class="haskell">isSublistOf</code> again)</h3>
<p>Реализовать в терминах <code class="haskell">isElemOf</code>:</p>
<pre><code class="haskell">isSublistOf :: (Eq a) =&gt; [a] -&gt; [a] -&gt; Bool
-- isSublistOf [] [] == True
-- isSublistOf [] [1, 2, 3] == True
-- isSublistOf [2, 1] [1, 2, 3] == True
-- isSublistOf [2, 4] [1, 2, 3] == False</code></pre>
<h3 id="step-5-multiple-constraints-in-a-context">Step 5 (Multiple constraints in a context)</h3>
<p>Введем еще классы для оператора <code class="haskell">(&lt;)</code> и для преобразования в строку:</p>
<pre><code class="haskell">class Ord a where
   (&lt;) :: a -&gt; a -&gt; Bool

class Show a where
   show :: a -&gt; String</code></pre>
<p>Теперь посмотрим на передачу <code class="haskell">(==)</code>, <code class="haskell">(&lt;)</code> и <code class="haskell">show</code> через контекст:</p>
<pre><code class="haskell">import Data.List (nub, sort)

-- sort :: (Ord a) =&gt; [a] -&gt; [a]
-- nub :: (Eq a) =&gt; [a] -&gt; [a]

f :: (Eq a, Ord a, Show a) =&gt; [a] -&gt; String
f = show . nub . sort</code></pre>
<p>В <code class="haskell">f</code> контекст состоит из <code class="haskell">(Eq a, Ord a, Show a)</code>. <code class="haskell">Eq a</code> неявно передается в <code class="haskell">nub</code>, <code class="haskell">Ord a</code> — в <code class="haskell">sort</code>, <code class="haskell">Show a</code> используется только в <code class="haskell">f</code> при вызове <code class="haskell">show</code>.</p>
<h3 id="step-6-parameters-in-a-class">Step 6 (Parameters in a class)</h3>
<pre><code class="haskell">data T a = T a

f :: (Eq (T a), Eq b, Eq a) =&gt; a -&gt; T a -&gt; b
f = ...</code></pre>
<p>У функции <code class="haskell">f</code> контекст дает три неявных аргумента с функциями:</p>
<pre><code class="haskell">(==) :: T a -&gt; T a -&gt; Bool
(==) :: b -&gt; b -&gt; Bool
(==) :: a -&gt; a -&gt; Bool</code></pre>
<p>В теле <code class="haskell">f</code> при встрече <code class="haskell">(==)</code> будет выбрана нужная реализация в зависимости от типа аргументов.</p>
<h3 id="step-7-typeclass-instances">Step 7 (Typeclass instances)</h3>
<p>Теперь, наладив неявную передачу, необходимо откуда-то взять саму реализацию. Как уже говорилось, равенство необходимо определять для каждого типа по-своему, что и сделаем. Синтаксически это выглядит так:</p>
<pre><code class="haskell">instance Eq Int where
   (I# i1) == (I# i2) = i1 ==# i2

instance (Eq a) =&gt; Eq [a] where
   [] == [] = True
   (x : xs) == (y : ys) = x == y &amp;&amp; xs == ys
   _ == _ = False</code></pre>
<p>Мы определяем эти <em>инстансы</em> на верхнем уровне и требуем, чтобы для каждого типа было не больше одного инстанса. Здесь <code class="haskell">(==#)</code> — встроенный оператор равенства для типа <code class="haskell">Int#</code>. Во втором клозе <code class="haskell">(==)</code> для списков в <code class="haskell">x == y</code> используется равенство из <code class="haskell">Eq a</code>, а в <code class="haskell">xs == ys</code> используется равенство из <code class="haskell">Eq [a]</code> (рекурсивный вызов).</p>
<h3 id="step-8-exercise-implement-eq-instance-for-binary-trees">Step 8 (Exercise: Implement Eq instance for binary trees)</h3>
<p>Реализовать инстанс <code class="haskell">Eq</code> для дерева:</p>
<pre><code class="haskell">data Tree a
   = Leaf a
   | Branch (Tree a) a (Tree a)</code></pre>
<h3 id="step-9-more-on-typeclasses">Step 9 (More on typeclasses)</h3>
<p>Но нужно ли ограничиваться одной функцией для класса типов? Нет, вот как определены классы <code class="haskell">Eq</code> и <code class="haskell">Ord</code> на самом деле:</p>
<pre><code class="haskell">class Eq a where
   (==) :: a -&gt; a -&gt; Bool
   (/=) :: a -&gt; a -&gt; Bool
   x /= y = not (x == y)

class (Eq a) =&gt; Ord a where
   compare :: a -&gt; a -&gt; Ordering
   compare x y
    | x == y = EQ
    | x &lt;= y = LT
    | otherwise = GT

   (&lt;), (&lt;=), (&gt;), (&gt;=) :: a -&gt; a -&gt; Bool
   x &lt; y =
      case compare x y of
         LT -&gt; True
         _ -&gt; False
   x &lt;= y =
      case compare x y of
         GT -&gt; False
         _ -&gt; True
   x &gt; y =
      case compare x y of
         GT -&gt; True
         _ -&gt; False
   x &gt;= y =
      case compare x y of
         LT -&gt; False
         _ -&gt; True

   max, min :: a -&gt; a -&gt; a
   max x y = if x &lt;= y then y else x
   min x y = if x &lt;= y then x else y

instance Eq Int where
   (I# i1) == (I# i2) = i1 ==# i2
   (I# i1) /= (I# i2) = i1 /=# i2

instance Eq a =&gt; Eq [a] where
   [] == [] = True
   (x : xs) == (y : ys) = x == y &amp;&amp; xs == ys
   _ == _ = False

instance (Ord a) =&gt; Ord [a] where
   compare [] [] = EQ
   compare [] (_ : _) = LT
   compare (_ : _) [] = GT
   compare (x : xs) (y : ys) =
      case compare x y of
         EQ -&gt; compare xs ys
         other -&gt; other

instance Ord Int where
   (I# x#) `compare` (I# y#)
    | isTrue# (x# &lt;# y#) = LT
    | isTrue# (x# ==# y#) = EQ
    | otherwise = GT
   (I# x) &lt; (I# y) = isTrue# (x &lt;# y)
   (I# x) &lt;= (I# y) = isTrue# (x &lt;=# y)
   (I# x) &gt;= (I# y) = isTrue# (x &gt;=# y)
   (I# x) &gt; (I# y) = isTrue# (x &gt;# y)</code></pre>
<p>Здесь в <code class="haskell">Eq</code> определены 2 функции <code class="haskell">(==)</code>, <code class="haskell">(/=)</code> и у <code class="haskell">(/=)</code> есть реализация по умолчанию. В инстансе для списка используется именно она, а в инстансе для <code class="haskell">Int</code> она переопределена в интересах эффективности.</p>
<p><code class="haskell">Ord</code> интереснее: во-первых, определяя инстанс для <code class="haskell">Ord</code>, необходимо так же определять инстанс <code class="haskell">Eq</code> (присутствие контекста <code class="haskell">(Eq a) =&gt;</code> при определении <code class="haskell">Ord</code>). Во-вторых, каждая функция имеет реализацию по-умолчанию. При этом, <code class="haskell">compare</code> определен через <code class="haskell">(&lt;=)</code> и <code class="haskell">(&lt;=)</code> определен через <code class="haskell">compare</code>. Поэтому, чтобы программа не ушла в бесконечный цикл, нужно определить хотя бы один из них. Обычно определяют либо <code class="haskell">compare</code>, либо все кроме <code class="haskell">max</code>, <code class="haskell">min</code>.</p>
<h3 id="step-10-exercise-implement-maplike">Step 10 (Exercise: implement <code class="haskell">MapLike</code>)</h3>
<p>Определить класс <code class="haskell">MapLike</code> с методами <code class="haskell">empty</code>, <code class="haskell">lookup</code>, <code class="haskell">insert</code>, <code class="haskell">delete</code>, <code class="haskell">fromList</code>. Они должны иметь ту же семантику, что и функции с этими именами в модуле <code class="haskell">Data.Map</code>. У <code class="haskell">fromList</code> должна быть реализация по умолчанию. Определить инстансы для <code class="haskell">Data.Map.Map</code> и для <code class="haskell">ListMap</code>:</p>
<pre><code class="haskell">newtype ListMap k v = ListMap [(k, v)]</code></pre>
<h3 id="step-11-philosophy">Step 11 (Philosophy)</h3>
<h4 id="математическая-интерпретация-классов">Математическая интерпретация классов</h4>
<p>Если рассматривать типы как множества, то классы типов можно понимать в математическом смысле: совокупность множеств, объединенная некоторым признаком.</p>
<p>В случае <code class="haskell">Eq</code> мы определяем совокупность множеств, таких что для каждого множества <code class="haskell">a</code> определена операция <code class="haskell">(==) :: a -&gt; a -&gt; Bool</code> и операция <code class="haskell">(/=) :: a -&gt; a -&gt; Bool</code>.</p>
<p>В случае <code class="haskell">Ord</code> мы определяем класс множеств, с операциями <code class="haskell">compare</code>, <code class="haskell">(&lt;)</code>, … и при условии, что множества из этого класса так же принадлежит классу <code class="haskell">Eq</code>. Инстансы тогда интерпретируются как свидетели принадлежности множества классу.</p>
<h4 id="сходства-с-java-интерфейсами">Сходства с Java интерфейсами</h4>
<p>Если смотреть на классы типов со стороны ООП, то они напоминают интерфейсы в Java. Но есть отличие: в Java конкретная реализация выбирается по неявному аргументу <code class="haskell">this</code>, а в Haskell участвует вся сигнатура функции:</p>
<pre><code class="haskell">class C a where
   m1 :: a -&gt; Integer
   m2 :: Integer -&gt; a
   m3 :: [a] -&gt; Integer

instance C Int where
   m1 x = ...
   m2 i = ...
   m3 xs = ...</code></pre>
<p>В <code class="haskell">f1</code>, <code class="haskell">f2</code>, <code class="haskell">f3</code> реализации <code class="haskell">m1</code>, <code class="haskell">m2</code>, <code class="haskell">m3</code> выбираются из инстанса <code class="haskell">C Int</code>:</p>
<pre><code class="haskell">a1, a2, a3 :: Int
a1 = 1
a2 = 2
a3 = 3

f1 :: Integer
f1 = m1 a1

f2 :: Int
f2 = m2 0

f3 :: Integer
f3 = m3 [a1, a2, a3]</code></pre>
<h2 id="классы-типов-show-и-read">Классы типов Show и Read</h2>
<h3 id="step-1-show">Step 1 (Show)</h3>
<p>Для преобразования в строку в Haskell есть класс типов <code class="haskell">Show</code>:</p>
<pre><code class="haskell">class Show a where
   show :: a -&gt; String</code></pre>
<p>Он в том числе используется ghci, чтобы напечатать результат. Вот пример реализации инстанса для бинарного дерева:</p>
<pre><code class="haskell">data Tree a
   = Leaf a
   | Branch (Tree a) a (Tree a)

instance Show a =&gt; Show (Tree a) where
   show (Leaf x) = show x
   show (Branch l x r) = &quot;(&quot; ++ show l ++ &quot;) &quot; ++ show x ++ &quot; (&quot; ++ show r ++ &quot;)&quot;</code></pre>
<h3 id="step-2-exercise-implement-show-instance-for-binary-trees-by-drawing">Step 2 (Exercise: Implement Show instance for binary trees by drawing)</h3>
<p>Реализовать инстанс <code class="haskell">Show</code> для деревьев, который бы “рисовал” деревья:</p>
<pre><code class="haskell">data Tree a
   = Leaf a
   | Branch (Tree a) a (Tree a)

-- show (Leaf 0) == &quot;0\n&quot;
-- show (Branch (Leaf 0) 1 (Leaf 2)) == &quot; 1 \n\
--                                      \0 2\n&quot;
-- show (Branch (Branch (Leaf 0) 24 (Leaf 22)) 45 (Branch (Branch (Leaf 34) 37 (Leaf 8)) 100 (Leaf 1))) ==
--    &quot;     45         \n\
--    \ 24         100 \n\
--    \0  22    37    1\n\
--    \       34  8    \n\</code></pre>
<p><em>Подсказка</em>: Напишите вспомогательную функцию, которая строит отрисованное дерево построчно (так проще склеивать два поддерева при обработке <code class="haskell">Branch</code>). А <code class="haskell">show</code> просто вызовет эту функцию и применит к результату <code class="haskell">unlines</code>.</p>
<h3 id="step-3-show-is-slow">Step 3 (Show is slow)</h3>
<p>Посмотрим теперь на производительность <code class="haskell">show</code>:</p>
<pre><code class="haskell">data Nat = S Nat | Z

instance Show Nat where
   show Z = &quot;0&quot;
   show (S n) = show n ++ &quot;+1&quot;

-- show (S (S Z)) =&gt;
-- show (S Z) ++ &quot;+1&quot; =&gt;
-- (show Z ++ &quot;+1&quot;) ++ &quot;+1&quot; =&gt;
-- (&quot;0&quot; ++ &quot;+1&quot;) ++ &quot;+1&quot;</code></pre>
<p>Мы получили последовательность скобок, при которой время работы <code class="haskell">(++)</code> наихудшее. Попробуем исправить ситуацию:</p>
<pre><code class="haskell">type ShowS = String -&gt; String

showNat :: Nat -&gt; ShowS
showNat Z = (&quot;0&quot; ++)
showNat (S n) = showNat n . (&quot;+1&quot; ++)

instance Show Nat where
   show n = showNat n &quot;&quot;

-- show (S (S Z)) =&gt;
-- showNat (S (S Z)) &quot;&quot; =&gt;
-- (showNat (S Z) . (&quot;+1&quot; ++)) &quot;&quot; =&gt;
-- ((showNat Z . (&quot;+1&quot; ++)) . (&quot;+1&quot; ++)) &quot;&quot; =&gt;
-- (((&quot;0&quot; ++) . (&quot;+1&quot; ++)) . (&quot;+1&quot; ++)) &quot;&quot; =&gt;
-- (\x -&gt; ((&quot;0&quot; ++) . (&quot;+1&quot; ++)) (&quot;+1&quot; ++ x)) &quot;&quot; =&gt;
-- (\x -&gt; (\y -&gt; &quot;0&quot; ++ (&quot;+1&quot; ++ y)) (&quot;+1&quot; ++ x)) &quot;&quot; =&gt;
-- (\x -&gt; &quot;0&quot; ++ (&quot;+1&quot; ++ (&quot;+1&quot; ++ x))) &quot;&quot; =&gt;
-- &quot;0&quot; ++ (&quot;+1&quot; ++ (&quot;+1&quot; ++ &quot;&quot;))</code></pre>
<p>Использование композиции для конкатенации строк исправило ситуацию.</p>
<h3 id="step-4-show-again">Step 4 (Show again)</h3>
<p>Этот трюк на самом деле используется и в самом <code class="haskell">Show</code>. Вот как он выглядит на самом деле:</p>
<pre><code class="haskell">class Show a where
   showPrec :: Int -&gt; a -&gt; ShowS
   show :: a -&gt; String
   showList :: [a] -&gt; ShowS</code></pre>
<p>Достаточно реализовать <code class="haskell">showPrec</code> <em>или</em> <code class="haskell">show</code>. <code class="haskell">showList</code> позволяет переопределить, как будет показываться список элементов (используется в <code class="haskell">Show Char</code> для обработки показывания <code class="haskell">String</code>). <code class="haskell">showPrec</code> также первым аргументом принимает приоритет оператора в окружающем контексте (от 0 до 11) — используется, например, при выводе инфиксных операторов.</p>
<p>Также есть набор вспомогательных функций:</p>
<pre><code class="haskell">shows :: (Show a) =&gt; a -&gt; ShowS
shows = showPrec 0

showChar :: Char -&gt; ShowS
showChar = (:)

showString :: String -&gt; ShowS
showString = (++)

showParen :: Bool -&gt; ShowS -&gt; ShowS
showParen b p = if b then showChar &#39;(&#39; . p . showChar &#39;)&#39; else p</code></pre>
<h3 id="step-5-exercise-implement-show-instance-for-expressions">Step 5 (Exercise: Implement Show instance for expressions)</h3>
<p>Реализовать инстанс <code class="haskell">Show</code> для арифметических выражений:</p>
<pre><code class="haskell">data Expr
   = Val Int
   | Sum Expr Expr
   | Mul Expr Expr

-- show (Sum (Mul (Val 1) (Val 2)) (Mul (Val 3) (Val 4))) == &quot;1 * 2 + 3 * 4&quot;
-- show (Mul (Sum (Val 1) (Val 2)) (Sum (Val 3) (Val 4))) == &quot;(1 + 2) * (3 + 4)&quot;
-- show (Sum (Val 1) (Sum (Val 2) (Val 3))) == &quot;1 + 2 + 3&quot;
-- show (Mul (Val 1) (Mul (Val 2) (Val 3))) == &quot;1 * 2 * 3&quot;</code></pre>
<h3 id="step-6-read">Step 6 (Read)</h3>
<h3 id="step-7-exercise-implement-show-and-read-instances-for-binary-trees-via-prüfer-coding">Step 7 (Exercise: Implement Show and Read instances for binary trees via Prüfer coding)</h3>
<h3 id="step-8-readprec-wo-delving-into-parser-combinators">Step 8 (ReadPrec (w/o delving into parser combinators))</h3>
<h2 id="класс-типов-num-и-его-наследники">Класс типов Num и его наследники</h2>
<h3 id="step-1-num">Step 1 (Num)</h3>
<h3 id="step-2-real">Step 2 (Real)</h3>
<h3 id="step-3-integral">Step 3 (Integral)</h3>
<h3 id="step-4-fractional">Step 4 (Fractional)</h3>
<h3 id="step-5-floating">Step 5 (Floating)</h3>
<h3 id="step-6-realfrac">Step 6 (RealFrac)</h3>
<h3 id="step-7-realfloat">Step 7 (RealFloat)</h3>
<h2 id="другие-стандартные-классы-типов">Другие стандартные классы типов</h2>
<h3 id="step-1-enum">Step 1 (Enum)</h3>
<h3 id="step-2-bounded">Step 2 (Bounded)</h3>
<h3 id="step-2.5-exercise-deriving-enum-bounded-into-cycle-with-safesuc-safepred">Step 2.5 (Exercise: Deriving Enum, Bounded into Cycle with safeSuc, safePred)</h3>
<h3 id="step-3-ix">Step 3 (Ix)</h3>
<h3 id="step-4-foldable">Step 4 (Foldable)</h3>
<h3 id="step-5-isstring">Step 5 (IsString)</h3>
<h2 id="расширения-классов-типов-и-производные-представители">Расширения классов типов и производные представители</h2>
<h3 id="step-1-deriving-standalone-deriving">Step 1 (deriving, standalone deriving)</h3>
<h3 id="step-2-type-synonym-instances">Step 2 (Type synonym instances)</h3>
<h3 id="step-3-orphan-instances">Step 3 (Orphan instances)</h3>
<h3 id="step-4-multiple-parameters">Step 4 (Multiple parameters)</h3>
<h3 id="step-5-functional-dependencies">Step 5 (Functional dependencies)</h3>
<h3 id="step-6-associated-type-families-putting-fun-into-functional-dependencies">Step 6 (Associated type families (putting fun into functional dependencies))</h3>
<h3 id="step-7-flexible-contexts-and-instances">Step 7 (Flexible contexts and instances)</h3>
<h3 id="step-8-overlapping-instances">Step 8 (Overlapping instances)</h3>
<h3 id="step-9-undecidable-instances">Step 9 (Undecidable instances)</h3>
</body>
</html>
